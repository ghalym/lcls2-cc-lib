PLC Project (1): Library
========================

    Project root: /home/travis/build/pcdshub/lcls2-cc-lib/lcls2-cc-lib
    Project path: Library/Library.plcproj
    TMC path:     Library/Library.tmc
    AMS ID:       
    IP Address:    (* based on AMS ID)
    Port:         851

    Source files:
        1.) Library/Devices/PPM/ENUM_PPM_States.TcDUT
        2.) Library/Devices/PPM/FB_PPM.TcPOU
        3.) Library/Devices/PPM/FB_PPM_Gige.TcPOU
        4.) Library/Devices/PPM/FB_PPM_PowerMeter.TcPOU
        5.) Library/Devices/PPM/FB_PPM_States.TcPOU
        6.) Library/Devices/REF/FB_REF.TcPOU
        7.) Library/Devices/REF/FB_REF_Laser.TcPOU
        8.) Library/Devices/XPIM/ENUM_XPIM_Filters.TcDUT
        9.) Library/Devices/XPIM/ENUM_XPIM_States.TcDUT
        10.) Library/Devices/XPIM/FB_XPIM.TcPOU
        11.) Library/Devices/XPIM/FB_XPIM_FilterWheel.TcPOU
        12.) Library/Devices/XPIM/FB_XPIM_Opal.TcPOU
        13.) Library/Devices/XPIM/FB_XPIM_States.TcPOU
        14.) Library/POUs/FB_L2SI_Flowmeter.TcPOU
        15.) Library/POUs/FB_XTES_Flowswitch.TcPOU
        16.) Library/Version/Global_Version.TcGVL

    GVLs:
        1.) Global_Version

Devices/PPM/ENUM_PPM_States.TcDUT (TcPlcObject)
-----------------------------------------------

### ENUM_PPM_States: Declaration

```vhdl
{attribute 'qualified_only'}
TYPE ENUM_PPM_States :
(
    Unknown := 0,
    Out := 1,
    PowerMeter := 2,
    PolishedYag := 3,
    FrostedYag := 4
);
END_TYPE
```


Devices/PPM/FB_PPM.TcPOU (TcPlcObject)
--------------------------------------

### FB_PPM: Declaration

```vhdl
FUNCTION_BLOCK FB_PPM
VAR_IN_OUT
    stYStage: DUT_MotionStage;
END_VAR
VAR_INPUT
    fOut: LREAL;
    fPower: LREAL;
    fPolished: LREAL;
    fFrosted: LREAL;
END_VAR
VAR
    fbYStage: FB_MotionStage;

    {attribute 'pytmc' := '
        pv: MMS:STATE
        io: i
    '}
    fbStates: FB_PPM_States;

    {attribute 'pytmc' := '
        pv: SPM
    '}
    fbPowerMeter: FB_PPM_PowerMeter;

    {attribute 'pytmc' := '
        pv: CAM
    '}
    fbGige: FB_PPM_Gige;

    {attribute 'pytmc' :='
        pv: SFM
    '}
    fbFlowMeter: FB_L2SI_Flowmeter;

    {attribute 'pytmc' := '
        pv: YAG
        io: input
    '}
    fbYagThermoCouple: FB_ThermoCouple;
END_VAR
```

### FB_PPM: ST

```vhdl
fbYStage(stMotionStage:=stYStage);
fbStates(
    stMotionStage:=stYStage,
    bEnable := TRUE,
    fOut:=fOut,
    fPower:=fPower,
    fPolished:=fPolished,
    fFrosted:=fFrosted);
stYStage.bHardwareEnable := TRUE;
stYStage.bPowerSelf := TRUE;
stYStage.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;
fbPowerMeter();
fbGige();
fbFlowMeter();
fbYagThermoCouple();
```


Devices/PPM/FB_PPM_Gige.TcPOU (TcPlcObject)
-------------------------------------------

### FB_PPM_Gige: Declaration

```vhdl
FUNCTION_BLOCK FB_PPM_Gige
VAR
    iIlluminatorINT AT %Q*: INT;

    {attribute 'pytmc' := '
        pv: PWR
        ZNAM: OFF
        ONAM: ON
    '}
    bGigePower AT %Q*: BOOL;

    {attribute 'pytmc' := '
        pv: CIL:PCT
        EGU: %
    '}
    fIlluminatorPercent: LREAL;

    fbGetIllPercent: FB_AnalogInput;
    fbSetIllPercent: FB_AnalogOutput;

    bGigeInit: BOOL := FALSE;
END_VAR
```

### FB_PPM_Gige: ST

```vhdl
// Turn the GigE on by default
IF NOT bGigeInit THEN
    bGigePower := TRUE;
    bGigeInit := TRUE;
END_IF

// Illuminator conversion to percentage
fbSetIllPercent(
    fReal:=fIlluminatorPercent,
    fSafeMax:=100,
    fSafeMin:=0,
    iTermBits:=15,
    fTermMax:=100,
    fTermMin:=0,
    iRaw=>iIlluminatorINT);
fbGetIllPercent(
    iRaw:=iIlluminatorINT,
    iTermBits:=15,
    fTermMax:=100,
    fTermMin:=0,
    fReal=>fIlluminatorPercent);
```


Devices/PPM/FB_PPM_PowerMeter.TcPOU (TcPlcObject)
-------------------------------------------------

### FB_PPM_PowerMeter: Declaration

```vhdl
FUNCTION_BLOCK FB_PPM_PowerMeter
VAR
    iVoltageINT AT %I*: INT;

    {attribute 'pytmc' := '
        pv: VOLT
        io: input
    '}
    fVoltage: LREAL;

    {attribute 'pytmc' := '
        pv: VOLT_BUFFER
        io: input
    '}
    fVoltageBuffer: ARRAY[1..1000] OF LREAL;

    {attribute 'pytmc' := '
        pv: CALIB
        io: input
    '}
    fCalibBase: LREAL;

    {attribute 'pytmc' := '
        pv: CALIB_BUFFER
        io: input
    '}
    fCalibBaseBuffer: ARRAY[1..1000] OF LREAL;

    {attribute 'pytmc' := '
        pv: MJ
        io: input
    '}
    fCalibMJ: LREAL;

    {attribute 'pytmc' := '
        pv: MJ_BUFFER
        io: input
    '}
    fCalibMJBuffer: ARRAY[1..1000] OF LREAL;

    {attribute 'pytmc' := '
        pv: STC
        io: input
    '}
    fbThermoCouple: FB_ThermoCouple;

    {attribute 'pytmc' := '
        pv: CALIB:OFFSET
        io: io
    '}
    fCalibRelOffset: LREAL;

    {attribute 'pytmc' := '
        pv: CALIB:RATIO
        io: io
    '}
    fCalibRelRatio: LREAL;

    {attribute 'pytmc' := '
        pv: CALIB:MJ_RATIO
        io: io
    '}
    fCalibMJRatio: LREAL;

    fbGetPMVoltage: FB_AnalogInput;
    fbVoltageBuffer: FB_LREALBuffer;
    fbCalibBaseBuffer: FB_LREALBuffer;
    fbCalibMJBuffer: FB_LREALBuffer;
END_VAR
```

### FB_PPM_PowerMeter: ST

```vhdl
fbThermoCouple();

// Convert the terminal's integer into a value in volts
fbGetPMVoltage(
    iRaw := iVoltageINT,
    iTermBits := 15,
    fTermMax := 10,
    fTermMin := 0,
    fReal => fVoltage);

// Power meter calibration
fCalibBase := (fVoltage + fCalibRelOffset) * fCalibRelRatio;
fCalibMJ := fCalibBase * fCalibMJRatio;

// Buffer the full-rate Voltage and calibrated MJ values
fbVoltageBuffer(
    bExecute := TRUE,
    fInput := fVoltage,
    arrOutput => fVoltageBuffer);
fbCalibBaseBuffer(
    bExecute := TRUE,
    fInput := fCalibBase,
    arrOutput => fCalibBaseBuffer);
fbCalibMJBuffer(
    bExecute := TRUE,
    fInput := fCalibMJ,
    arrOutput => fCalibMJBuffer);
```


Devices/PPM/FB_PPM_States.TcPOU (TcPlcObject)
---------------------------------------------

### FB_PPM_States: Declaration

```vhdl
FUNCTION_BLOCK FB_PPM_States
VAR_IN_OUT
    stMotionStage: DUT_MotionStage;
END_VAR
VAR_INPUT
    bEnable: BOOL;
    {attribute 'pytmc' := '
        pv: SET
        io: io
    '}
    enumSet: ENUM_PPM_states;
    bStatesLock: BOOL;
    fOut: LREAL;
    fPower: LREAL;
    fPolished: LREAL;
    fFrosted: LREAL;
END_VAR
VAR_OUTPUT
    bError: BOOL;
    sErrorMessage: STRING;
    bBusy: BOOL;
    bDone: BOOL;
    {attribute 'pytmc' := '
        pv: GET
        io: i
    '}
    enumGet: ENUM_PPM_States;
END_VAR
VAR
    bInit: BOOL;
    arrStates: ARRAY[1..15] OF DUT_PositionState;
    nIter: INT;

    {attribute 'pytmc' := '
        pv:
        io: io
    '}
    fbStateManager: FB_PositionStateManager;

    fbLockOut: FB_PositionStateLock;
    fbLockPowerMeter: FB_PositionStateLock;
    fbLockPolishedYag: FB_PositionStateLock;
    fbLockFrostedYag: FB_PositionStateLock;
END_VAR
VAR CONSTANT
    fInDelta: LREAL := 0.1;
    fOutDelta: LREAL := 10;
    fInVelocity: LREAL := 80;
    fOutVelocity: LREAL := 65;
    fAccel: LREAL := 200;
    fOutDecel: LREAL := 25;
END_VAR
```

### FB_PPM_States: ST

```vhdl
IF NOT bInit THEN
    bInit := FALSE;
    FOR nIter := 1 TO 4 DO
        arrStates[nIter].fDelta := fInDelta;
        arrStates[nIter].fVelocity := fInVelocity;
        arrStates[nIter].fAccel := fAccel;
        arrStates[nIter].fDecel := fAccel;
        arrStates[nIter].bLocked := bStatesLock;
        arrStates[nIter].bValid := TRUE;
        // TODO implement PMPS instead of doing this
        arrStates[nIter].bMoveOk := TRUE;
    END_FOR
    arrStates[1].sName := 'Out';
    arrStates[1].fPosition := fOut;
    arrStates[1].fDelta := fOutDelta;
    arrStates[1].fVelocity := fOutVelocity;
    arrStates[1].fDecel := fOutDecel;
    arrStates[2].sName := 'PowerMeter';
    arrStates[2].fPosition := fPower;
    arrStates[3].sName := 'PolishedYag';
    arrStates[3].fPosition := fPolished;
    arrStates[4].sName := 'FrostedYag';
    arrStates[4].fPosition := fFrosted;
END_IF

fbLockOut(stPositionState := arrStates[1]);
fbLockPowerMeter(stPositionState := arrStates[2]);
fbLockPolishedYag(stPositionState := arrStates[3]);
fbLockFrostedYag(stPositionState := arrStates[4]);

fbStateManager(
    stMotionStage := stMotionStage,
    arrStates := arrStates,
    setState := enumSet,
    bEnable := bEnable,
    bError => bError,
    sErrorMessage => sErrorMessage,
    bBusy => bBusy,
    bDone => bDone,
    getState => enumGet);
```


Devices/REF/FB_REF.TcPOU (TcPlcObject)
--------------------------------------

### FB_REF: Declaration

```vhdl
FUNCTION_BLOCK FB_REF
VAR_IN_OUT
    stYStage: DUT_MotionStage;
END_VAR
VAR_INPUT
    fIn: LREAL;
    fOut: LREAL;
END_VAR
VAR
    fbYStage: FB_MotionStage;
    {attribute 'pytmc' := '
        pv: MMS:STATE
        io: io
    '}
    fbStates: FB_EpicsInOut;

    {attribute 'pytmc' := '
        pv: LAS
        io: io
    '}
    fbLaser: FB_REF_Laser;

    bInit: BOOL;
    stOut: DUT_PositionState;
    stIn: DUT_PositionState;
END_VAR
VAR CONSTANT
    bStatesLock: BOOL;
    fVelo: LREAL := 65;
    fAccel: LREAL := 25;
END_VAR
```

### FB_REF: ST

```vhdl
IF NOT bInit THEN
    bInit := TRUE;
    stOut.fPosition := fOut;
    stOut.fDelta := 10;
    stOut.fVelocity := fVelo;
    stOut.fAccel := fAccel;
    stOut.fDecel := fAccel;
    stOut.bLocked := bStatesLock;
    stOut.bValid := TRUE;
    stOut.bMoveOk := TRUE;

    stIn.fPosition := fIn;
    stIn.fDelta := 0.1;
    stIn.fVelocity := fVelo;
    stIn.fAccel := fAccel;
    stIn.fDecel := fAccel;
    stIn.bLocked := bStatesLock;
    stIn.bValid := TRUE;
    stIn.bMoveOk := TRUE;
END_IF

fbYStage(stMotionStage:=stYStage);
fbStates(
    stMotionStage:=stYStage,
    stOut := stOut,
    stIn := stIn);
stYStage.bHardwareEnable := TRUE;
stYStage.bPowerSelf := TRUE;
stYStage.nEnableMode := ENUM_StageEnableMode.DURING_MOTION;
fbLaser();
```


Devices/REF/FB_REF_Laser.TcPOU (TcPlcObject)
--------------------------------------------

### FB_REF_Laser: Declaration

```vhdl
FUNCTION_BLOCK FB_REF_Laser
VAR_INPUT
    bShutdown: BOOL;

    {attribute 'pytmc' := '
        pv: PCT
        io: io
    '}
    fLaserPercent: LREAL;
END_VAR
VAR
    iShutdownINT AT %Q*: INT;
    iLaserINT AT %Q*: INT;

    fbGetLasPercent: FB_AnalogInput;
    fbSetLasPercent: FB_AnalogOutput;
END_VAR
```

### FB_REF_Laser: ST

```vhdl
// Send 5V to suppress laser
IF bShutdown THEN
    iShutdownINT := LREAL_TO_INT(EXPT(2, 14));
ELSE
    iShutdownINT := 0;
END_IF

// Limit to 0-5V instead of 10V
fbSetLasPercent(
    fReal:=fLaserPercent,
    fSafeMax:=100,
    fSafeMin:=0,
    iTermBits:=15,
    fTermMax:=200,
    fTermMin:=0,
    iRaw=>iLaserInt);
fbGetLasPercent(
    iRaw:=iLaserInt,
    iTermBits:=15,
    fTermMax:=200,
    fTermMin:=0,
    fReal=>fLaserPercent);
```


Devices/XPIM/ENUM_XPIM_Filters.TcDUT (TcPlcObject)
--------------------------------------------------

### ENUM_XPIM_Filters: Declaration

```vhdl
{attribute 'qualified_only'}
TYPE ENUM_XPIM_Filters :
(
    Unknown := 0,
    T50 := 1,
    T25 := 2,
    T10 := 3,
    T5 := 4,
    T1 := 5,
    T100 := 6
);
END_TYPE
```


Devices/XPIM/ENUM_XPIM_States.TcDUT (TcPlcObject)
-------------------------------------------------

### ENUM_XPIM_States: Declaration

```vhdl
{attribute 'qualified_only'}
TYPE ENUM_XPIM_States :
(
    Unknown := 0,
    Out := 1,
    Yag := 2,
    Diamond := 3,
    Reticle := 4
);
END_TYPE
```


Devices/XPIM/FB_XPIM.TcPOU (TcPlcObject)
----------------------------------------

### FB_XPIM: Declaration

```vhdl
FUNCTION_BLOCK FB_XPIM
VAR_IN_OUT
    stYStage: DUT_MotionStage;
    stZoomStage: DUT_MotionStage;
    stFocusStage: DUT_MotionStage;
    stEl6In: EL6inData22b;
    stEl6Out: EL6OutData22b;
END_VAR
VAR_INPUT
    bZoomEndFwd AT %I*: BOOL;
    bZoomEndBwd AT %I*: BOOL;
    bFocusEndFwd AT %I*: BOOL;
    bFocusEndBwd AT %I*: BOOL;

    fYag: LREAL;
    fDiamond: LREAL;
    fReticle: LREAL;
    fOut: LREAL;
END_VAR
VAR
    fbYStage: FB_MotionStage;
    fbZoom: FB_MotionStage;
    fbFocus: FB_MotionStage;

    {attribute 'pytmc' := '
        pv: MMS:STATE
        io: io
    '}
    fbStates: FB_XPIM_States;

    {attribute 'pytmc' := '
        pv: MFW
    '}
    fbFilterWheel: FB_XPIM_FilterWheel;

    {attribute 'pytmc' := '
        pv: CAM
    '}
    fbOpal: FB_XPIM_Opal;

    {attribute 'pytmc' := '
        pv: SFW
    '}
    fbFlowSwitch: FB_XTES_Flowswitch;
END_VAR
```

### FB_XPIM: ST

```vhdl
fbYStage(stMotionStage:=stYStage);
// All stages have no STO
stYStage.bHardwareEnable := TRUE;
stZoomStage.bHardwareEnable := TRUE;
stFocusStage.bHardwareEnable := TRUE;
// No limit switch at the bottom
stYStage.bLimitBackwardEnable := TRUE;
// Lens limits are normally open
stZoomStage.bLimitForwardEnable := NOT bZoomEndFwd;
stZoomStage.bLimitBackwardEnable := NOT bZoomEndBwd;
stFocusStage.bLimitForwardEnable := NOT bFocusEndFwd;
stFocusStage.bLimitBackwardEnable := NOT bFocusEndBwd;
// Home Lens to LLS
stZoomStage.nHomingMode := ENUM_EpicsHomeCmd.LOW_LIMIT;
stFocusStage.nHomingMode := ENUM_EpicsHomeCmd.LOW_LIMIT;
fbStates(
    stMotionStage:=stYStage,
    fYag:=fYag,
    fDiamond:=fDiamond,
    fReticle:=fReticle,
    fOut:=fOut);
fbZoom(stMotionStage:=stZoomStage);
fbFocus(stMotionStage:=stFocusStage);
fbFilterWheel(
    bExecute:=TRUE,
    stIn_El6:=stEl6In,
    stOut_El6:=stEl6Out);
fbOpal();
fbFlowSwitch();
```


Devices/XPIM/FB_XPIM_FilterWheel.TcPOU (TcPlcObject)
----------------------------------------------------

### FB_XPIM_FilterWheel: Declaration

```vhdl
FUNCTION_BLOCK FB_XPIM_FilterWheel
VAR_INPUT
    bExecute: BOOL;

    {attribute 'pytmc' := '
        pv: ERR:RESET
        io: output
    '}
    bResetError: BOOL;

    {attribute 'pytmc' := '
        pv: SET
        io: io
    '}
    nSetPos: ENUM_XPIM_States;
END_VAR
VAR_OUTPUT
    {attribute 'pytmc' := '
        pv: GET
        io: i
    '}
    nGetPos: ENUM_XPIM_States;
    bBusy: BOOL;
    bError: BOOL;
    sError: STRING;
    {attribute 'pytmc' := '
        pv: ERR:MSG
        io: input
    '}
    sLastError: STRING;
    sErrorTS: STRING;
END_VAR
VAR_IN_OUT
    stIn_EL6: EL6inData22B;
    stOut_EL6: EL6outData22B;
END_VAR
VAR
    {attribute 'pytmc' := '
        pv: RAW
    '}
    fbCom: FB_EL6_COM;

    nStep: USINT;
    sLastTestCmd: STRING;
    bIsTest: BOOL;
    fbGetTime: NT_GetTime;
    bStopOnErr: BOOL;
END_VAR
```

### FB_XPIM_FilterWheel: ST

```vhdl
fbCom.sSendSuffix := '$R';
fbCom.sRecvSuffix := '$R';

IF bExecute AND nStep = 0 THEN
    IF bResetError OR NOT bError THEN
        nStep := 10;
    END_IF
ELSIF NOT bExecute THEN
    nStep := 0;
END_IF
CASE nStep OF
    0:
        ; // idle
    10:
        // Get position
        bIsTest := FALSE;
        fbCom(sCmd:='pos?',
            bSend:=TRUE,
            stIn_EL6:=stIn_EL6,
            stOut_EL6:=stOut_EL6);
        nStep := nStep + 10;
    20:
        // Wait for response and set variables
        fbCom(stIn_EL6:=stIn_EL6,
            stOut_EL6:=stOut_EL6);
        IF fbCom.bDone THEN
            bError := FALSE;
            sError := '';
            nGetPos := STRING_TO_USINT(fbCom.sResponse);
            nSetPos := nGetPos;
            nStep := nStep + 10;
            IF nGetPos = 0 THEN
                sError := 'Filter wheel in invalid state';
                bStopOnErr := TRUE;
                nStep := 50;
            END_IF
        END_IF
    30:
        // Wait for a move request
        IF nSetPos <> nGetPos THEN
            fbCom(sCmd:=CONCAT('pos=', INT_TO_STRING(nSetPos)),
                bSend:=TRUE,
                stIn_EL6:=stIn_EL6,
                stOut_EL6:=stOut_EL6);
            nStep := nStep + 10;
            bBusy := TRUE;
        END_IF
    40:
        fbCom(stIn_EL6:=stIn_EL6,
            stOut_EL6:=stOut_EL6);
        // Wait for move to be done
        IF fbCom.bDone THEN
            bBusy := FALSE;
            nStep := 10;
            // Handle setpoint error
            IF fbCom.sResponse = 'Command error CMD_ARG_INVALID$N$R' THEN
                sError := 'Invalid set position';
                nStep := 50;
            END_IF
        END_IF
    50:
        // Set sError and then jump here for standard handling
        sLastError := sError;
        bError := TRUE;
        fbGetTime(NETID:='',
            START:=TRUE);
        nStep := nStep + 10;
    60:
        // Error handling continued
        fbGetTime();
        IF NOT fbGetTime.BUSY THEN
            sErrorTS := SYSTEMTIME_TO_STRING(fbGetTime.TIMESTR);
            fbGetTime.START := FALSE;
            // set bStopOnErr to TRUE if it was a major error
            IF bStopOnErr THEN
                nStep := 0;
            ELSE
                nStep := 10;
            END_IF
            bStopOnErr := FALSE;
        END_IF
END_CASE
// Check for inner comms errors, report to EPICS same way
IF NOT bError AND
    (fbCom.eRecvErrorID <> COMERROR_NOERROR
    OR fbCom.eSendErrorID <> COMERROR_NOERROR
    OR fbCom.eRecvErrorID <> COMERROR_NOERROR) THEN
    sError := 'Serial Communication Error';
    bStopOnErr := TRUE;
    nStep := 50;
END_IF
```


Devices/XPIM/FB_XPIM_Opal.TcPOU (TcPlcObject)
---------------------------------------------

### FB_XPIM_Opal: Declaration

```vhdl
FUNCTION_BLOCK FB_XPIM_Opal
VAR
    {attribute 'pytmc' := '
        pv: PWR
        io: io
        ZNAM: OFF
        ONAM: ON
    '}
    bOpalPower AT %Q*: BOOL;
    bOpalInit: BOOL := FALSE;

    {attribute 'pytmc' := '
        pv: CIL:PWR
        io: io
        ZNAM: OFF
        ONAM: ON
    '}
    bLedPower AT %Q*: BOOL;
END_VAR
```

### FB_XPIM_Opal: ST

```vhdl
// Turn the Opal on by default
IF NOT bOpalInit THEN
    bOpalPower := TRUE;
    bOpalInit := TRUE;
END_IF
```


Devices/XPIM/FB_XPIM_States.TcPOU (TcPlcObject)
-----------------------------------------------

### FB_XPIM_States: Declaration

```vhdl
FUNCTION_BLOCK FB_XPIM_States
VAR_IN_OUT
    stMotionStage: DUT_MotionStage;
END_VAR
VAR_INPUT
    bEnable: BOOL;
    {attribute 'pytmc' := '
        pv: SET
        io: io
    '}
    enumSet: ENUM_PPM_states;
    bStatesLock: BOOL;
    fOut: LREAL;
    fYag: LREAL;
    fDiamond: LREAL;
    fReticle: LREAL;
END_VAR
VAR_OUTPUT
    bError: BOOL;
    sErrorMessage: STRING;
    bBusy: BOOL;
    bDone: BOOL;
    {attribute 'pytmc' := '
        pv: GET
        io: i
    '}
    enumGet: ENUM_XPIM_States;
END_VAR
VAR
    bInit: BOOL;
    arrStates: ARRAY[1..15] OF DUT_PositionState;
    nIter: INT;

    {attribute 'pytmc' := '
        pv:
        io: io
    '}
    fbStateManager: FB_PositionStateManager;

    fbLockOut: FB_PositionStateLock;
    fbLockYag: FB_PositionStateLock;
    fbLockDiamond: FB_PositionStateLock;
    fbLockReticle: FB_PositionStateLock;
END_VAR
VAR CONSTANT
    fInDelta: LREAL := 0.1;
    fOutDelta: LREAL := 10;
    fInVelocity: LREAL := 20;
    fOutVelocity: LREAL := 20;
    fAccel: LREAL := 200;
    fOutDecel: LREAL := 25;
END_VAR
```

### FB_XPIM_States: ST

```vhdl
IF NOT bInit THEN
    bInit := FALSE;
    FOR nIter := 1 TO 4 DO
        arrStates[nIter].fDelta := fInDelta;
        arrStates[nIter].fVelocity := fInVelocity;
        arrStates[nIter].fAccel := fAccel;
        arrStates[nIter].fDecel := fAccel;
        arrStates[nIter].bLocked := bStatesLock;
        arrStates[nIter].bValid := TRUE;
        // TODO implement PMPS instead of doing this
        arrStates[nIter].bMoveOk := TRUE;
    END_FOR
    arrStates[1].sName := 'Out';
    arrStates[1].fPosition := fOut;
    arrStates[1].fDelta := fOutDelta;
    arrStates[1].fVelocity := fOutVelocity;
    arrStates[1].fDecel := fOutDecel;
    arrStates[2].sName := 'Yag';
    arrStates[2].fPosition := fYag;
    arrStates[3].sName := 'Diamond';
    arrStates[3].fPosition := fDiamond;
    arrStates[4].sName := 'Reticle';
    arrStates[4].fPosition := fReticle;
END_IF

fbLockOut(stPositionState := arrStates[1]);
fbLockYag(stPositionState := arrStates[2]);
fbLockDiamond(stPositionState := arrStates[3]);
fbLockReticle(stPositionState := arrStates[4]);

fbStateManager(
    stMotionStage := stMotionStage,
    arrStates := arrStates,
    setState := enumSet,
    bEnable := bEnable,
    bError => bError,
    sErrorMessage => sErrorMessage,
    bBusy => bBusy,
    bDone => bDone,
    getState => enumGet);
```


POUs/FB_L2SI_Flowmeter.TcPOU (TcPlcObject)
------------------------------------------

### FB_L2SI_Flowmeter: Declaration

```vhdl
FUNCTION_BLOCK FB_L2SI_Flowmeter
VAR
    {attribute 'pytmc' := '
        pv: MA
        io: input
    '}
    fRaw AT %I*: INT;

    {attribute 'pytmc' := '
        pv: FLOW
        io: input
    '}
    fFlowRate: LREAL;
END_VAR
```


POUs/FB_XTES_Flowswitch.TcPOU (TcPlcObject)
-------------------------------------------

### FB_XTES_Flowswitch: Declaration

```vhdl
FUNCTION_BLOCK FB_XTES_Flowswitch
VAR_OUTPUT
    {attribute 'pytmc' := '
        pv: FLOW
        ZNAM: LOW
        ONAM: OK
    '}
    bFlowOk AT %I*: BOOL;
END_VAR
```


Version/Global_Version.TcGVL (TcPlcObject)
------------------------------------------

### Global_Version: Declaration

```vhdl
{attribute 'TcGenerated'}
{attribute 'no-analysis'}
// This function has been automatically generated from the project information.
VAR_GLOBAL CONSTANT
	{attribute 'const_non_replaced'}
	{attribute 'linkalways'}
	stLibVersion_lcls2_cc_lib : ST_LibVersion := (iMajor := 0, iMinor := 0, iBuild := 0, iRevision := 0, sVersion := '0.0.0');
END_VAR
```


Symbols
-------


Boxes
-----

NC axes
-------

Links
-----


Pragma lint results
-------------------
```
INFO:pytmc.bin.pragmalint:Total pragmas found: 47 Total linter errors: 0
PLC Project (1): Library
========================


Devices/PPM/ENUM_PPM_States.TcDUT (TcPlcObject)
-----------------------------------------------

    - ENUM_PPM_States: Declaration - 1 pragmas


Devices/PPM/FB_PPM.TcPOU (TcPlcObject)
--------------------------------------

    - FB_PPM: Declaration - 5 pragmas


Devices/PPM/FB_PPM_Gige.TcPOU (TcPlcObject)
-------------------------------------------

    - FB_PPM_Gige: Declaration - 2 pragmas


Devices/PPM/FB_PPM_PowerMeter.TcPOU (TcPlcObject)
-------------------------------------------------

    - FB_PPM_PowerMeter: Declaration - 10 pragmas


Devices/PPM/FB_PPM_States.TcPOU (TcPlcObject)
---------------------------------------------

    - FB_PPM_States: Declaration - 3 pragmas


Devices/REF/FB_REF.TcPOU (TcPlcObject)
--------------------------------------

    - FB_REF: Declaration - 2 pragmas


Devices/REF/FB_REF_Laser.TcPOU (TcPlcObject)
--------------------------------------------

    - FB_REF_Laser: Declaration - 1 pragmas


Devices/XPIM/ENUM_XPIM_Filters.TcDUT (TcPlcObject)
--------------------------------------------------

    - ENUM_XPIM_Filters: Declaration - 1 pragmas


Devices/XPIM/ENUM_XPIM_States.TcDUT (TcPlcObject)
-------------------------------------------------

    - ENUM_XPIM_States: Declaration - 1 pragmas


Devices/XPIM/FB_XPIM.TcPOU (TcPlcObject)
----------------------------------------

    - FB_XPIM: Declaration - 4 pragmas


Devices/XPIM/FB_XPIM_FilterWheel.TcPOU (TcPlcObject)
----------------------------------------------------

    - FB_XPIM_FilterWheel: Declaration - 5 pragmas


Devices/XPIM/FB_XPIM_Opal.TcPOU (TcPlcObject)
---------------------------------------------

    - FB_XPIM_Opal: Declaration - 2 pragmas


Devices/XPIM/FB_XPIM_States.TcPOU (TcPlcObject)
-----------------------------------------------

    - FB_XPIM_States: Declaration - 3 pragmas


POUs/FB_L2SI_Flowmeter.TcPOU (TcPlcObject)
------------------------------------------

    - FB_L2SI_Flowmeter: Declaration - 2 pragmas


POUs/FB_XTES_Flowswitch.TcPOU (TcPlcObject)
-------------------------------------------

    - FB_XTES_Flowswitch: Declaration - 1 pragmas


Version/Global_Version.TcGVL (TcPlcObject)
------------------------------------------

    - Global_Version: Declaration - 4 pragmas

```
